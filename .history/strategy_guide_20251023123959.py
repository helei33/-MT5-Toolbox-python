GUIDE_TEXT = '''# 交易策略库设计模式与使用说明

## 设计模式分析
这个工具箱的策略功能采用的是一种 **“插件式”** 设计模式。

- **发现机制**：主程序在启动时，会自动扫描 `strategies` 文件夹，寻找所有 `.py` 结尾的文件，并将它们作为潜在的策略插件。
- **加载机制**：主程序会动态地加载这些文件，并在其中寻找一个继承了内置 `BaseStrategy` 基类的策略类。
- **实例化与运行**：当用户为某个账户选择并启动一个策略时，主程序会创建这个策略类的一个实例，并在一个独立的后台线程中调用它的 `run()` 方法来执行策略逻辑。策略的参数、账户信息等都是在此时传递给策略实例的。

---

## 编写策略的规则
一个合规的策略脚本必须遵循以下规则：

1.  **文件位置**：必须是独立的 `.py` 文件，且必须放在 `strategies` 文件夹内。

2.  **核心类**：文件中必须定义一个策略类，这个类必须继承自 `BaseStrategy`。

3.  **元数据（必填）**：策略类中必须包含以下几个类属性，用来告诉主程序它的基本信息：
    - `strategy_name`: (字符串) 策略的名称，会显示在UI界面。
    - `strategy_description`: (字符串) 对策略功能的详细描述。
    - `strategy_params_config`: (字典) 定义了哪些参数可以被用户配置。主程序会根据这个字典自动生成配置界面。

4.  **核心逻辑（必填）**：策略的主要运行逻辑必须实现在 `run(self)` 方法中。这个方法应该是一个循环，并且在循环中通过 `self.is_running()` 来判断是否应该继续运行，以便主程序可以随时安全地停止它。

5.  **与主程序交互**：
    - 在 `__init__` 方法中，策略会接收到 `config` (账户配置), `log_queue` (日志队列), 和 `params` (用户配置好的参数)。
    - 可以通过 `self.log_queue.put("日志内容")` 将日志发送到主界面的日志窗口。

---

## 策略代码模板（可复制使用）

```python
# 注意：无需手动导入 BaseStrategy，主程序会自动注入
# from XXX import BaseStrategy 

class MyAwesomeStrategy(BaseStrategy):
    # --- 策略元数据 ---
    strategy_name = "我的高频策略"
    strategy_description = """
这是一个示例策略，它会：
1. 每隔10秒检查一次。
2. 打印一条日志。
3. 可以在参数中配置检查间隔。
    """.strip()
    
    strategy_params_config = {
        "check_interval_seconds": {
            "label": "检查间隔(秒)",
            "type": "int",
            "default": 10
        },
        "magic_number": {
            "label": "交易魔术号",
            "type": "int",
            "default": 123456
        }
    }

    # ... (此处省略 __init__ 和 run 方法的实现细节)
```
'''